// Registers new types with driver
function RegisterTypes(driver)
{
//    signature:
//    driver.RegisterType(type_name, regex, eval_func, parse_func);

    // wxString
/*    driver.RegisterType(
        _T("wxString"),
        _T("[^[:alnum:]_]*wxString[^[:alnum:]_]*"),
        _T("Evaluate_wxString"),
        _T("Parse_wxString")
    );
*/
    // STL String
    driver.RegisterType(
        _T("STL String"),
        _T("[^[:alnum:]_]+string[^[:alnum:]_]*"),
        _T("Evaluate_StlString"),
        _T("Parse_StlString")
    );

/*    // STL Vector
    driver.RegisterType(
        _T("STL Vector"),
        _T("[^[:alnum:]_]*vector<.*"),
        _T("Evaluate_StlVector"),
        _T("Parse_StlVector")
    );
*/
}
/*
////////////////////////////////////////////////////////////////////////////////
// wxString
////////////////////////////////////////////////////////////////////////////////

// This function tells the driver how to evaluate this type.
// a_str contains the variable.
// start contains the starting position. Useful for arrays.
// count contains the count of evaluation. Useful for arrays. If 0, evaluate from start (variable) to end of array.
// result must contain the debugger's command when it returns.
function Evaluate_wxString(type, a_str, start, count)
{
    result = _T("output /c ") + a_str + _T(".c_str()[") + start + _T("]@");
    if (count != 0)
        result = result + count;
    else
        result = result + a_str + _T(".size()");
    return result;
}

// This function parses driver's output.
// When it returns, the _T("result") argument contains the parsing result.
function Parse_wxString(const wxString& in a_str, uint start, wxString& out result)
{
    result = _T("\")";
    uint len = a_str.length();
    uint c = 0;
    while (c < len)
    {
        switch (a_str[c])
        {
            case '\'':
                ++c;
                while (c < len)
                {
                    switch (a_str[c])
                    {
                        case '\\':
                            result += a_str[c++];
                            result += a_str[c++];
                            break;
                        default:
                            result += a_str[c++];
                            break;
                    }
                    if (a_str[c] == '\'')
                        break;
                }
                break;

            default:
                break;
        }
        ++c;
    }
    result += _T("\")";
}
*/
////////////////////////////////////////////////////////////////////////////////
// STL String
////////////////////////////////////////////////////////////////////////////////

function Evaluate_StlString(type, a_str, start, count)
{
    result = _T("output ") + a_str + _T(".c_str()[") + start + _T("]@");
    if (count != 0)
        result = result + count;
    else
        result = result + a_str + _T(".size()");
    return result;
}

function Parse_StlString(a_str, start)
{
    // nothing needs to be done
    return a_str;
}
/*
////////////////////////////////////////////////////////////////////////////////
// STL Vector
////////////////////////////////////////////////////////////////////////////////

function Evaluate_StlVector(const wxString& in type, const wxString& in a_str, uint start, uint count, wxString& out result)
{
    wxString t = type.AfterFirst('<').BeforeFirst(',');
    result = _T("output ((") + t + _T("*)") + a_str + _T(".begin())[") + start + _T("]@");
    if (count != 0)
        result += count;
    else
        result += a_str + _T(".size() - ") + start;
}

function Parse_StlVector(const wxString& in a_str, uint start, wxString& out result)
{
    // add [] indexes in front of each value
    int len = a_str.length();
    int c = 0;
    int index = start;
    while (c < len)
    {
        result += a_str[c];
        switch (a_str[c])
        {
            case '{':
            case ',':
                result += _T("[") + index++ + _T("] = ");
                break;
            default: break;
        }
        ++c;
    }
}
*/