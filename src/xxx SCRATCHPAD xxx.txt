Behaviours
-----------
Behaviours are compiler-agnostic. They must be understood by all compilers, even if not supported (in which case they 're simply not used).

Behaviours can only be either boolean values (on, off, explicitely off) or choices.

Booleans: The value "off" refers more correctly to "not on in this context", but may still result being "on" due to inheritance. Contrarily, "explicitely off" does not honour any ancestors.
Choices: Choices are declared in behaviours.xml (user visible text and identifiers), and must either be not implemented at all, or implemented
exactly like they were declared in the compiler file (map identifiers to commandline options).


Properties
----------
Properties are compiler specific. Each compiler defines the properties it supports.
Properties can be booleans, choices, integers, strings, and string arrays. As a special case of strings, filenames and pathnames are allowed,
these are implemented as strings but can be declared as being absolute or relative (and are normalized accordingly),
also they may offer a more sophisticated GUI.



Naming scheme of compiler files
-------------------------------
vendor-family/majorminorversion-os.xml

Examples:
dm-dm84-cpp-windows.xml
mingw-gcc34-cpp-windows.xml
gnu-gcc34-cpp-linux.xml
gnu-gcc41-cpp-linux.xml

The idea behind this is to
a) have an unique identifier for every compiler
b) be able to provide different sets for significantly different versions of the same compiler (gcc 3.x/4.x)
c) be able to distinguish between gcc, MinGW, cygwin, and dejagnu (which all belong to the gcc family)
d) easily sort out compilers that are not for the target OS (this is done by the update script already)



Compiler file format
------------------

Tools:
- define the tool 
   - search locations
       The special form 'alias:name' means "same as tool 'name'".
   - file name
       The special form 'alias:name' means "same as tool 'name'". If an alias for the *executable* is given, no path is needed.
   - challenge and response (there may be several responses, all must match
Only names that have been declared earlier in the document can be referenced as alias (no, I am not going to implement recursive aliasing...).


Stages:
Stages are defined via the <stage> tag. The number of stages is _not_ defined beforehand. Stages are run in the order they 're specified in the xml file.
An id and a human-readable title may be provided as attributes as well as the run attribute, which determines whether this stage
runs on individual files (compiler) or on the collection of target files (linker).
The id tag is used to include/exclude certain stages for a file type set from inside a <family> section in the layout.xml file.
All defined stages run sequentially in their order of appearance, omitting file types not listed in the layout.xml file.
The title tag is a human readable description (such as "Compiling") which may be used for the build log.
The following "standard" stage ids shall be used for "normal" compiler operation: precompile, compile, link.

The stage with the special ID "END" (capital) causes all following stages to be ignored during build.
This allows stages to be defined which will never be executed during build but which may be called by their ID.
For example, the code completion plugin might call the special stage "includedirs" with an empty dummy file, which might execute
"gcc -v -E -x c++ dummyfile.cpp" and parse the compiler's output to find out the system include dirs.




For each stage:
- command: the complete commandline needed to run a stage
  A command may be assigned a mode. This is to honour the different modes of invokation, for example
  to build a static or dynamic library, or to generate precompiled headers alongside the header or in another folder.
  If the application provides a mode when querying the commandline, only a matching commandline is returned.
  If no mode is provided, the first command found is returned (which should be the only one anyway).
- implement behaviours: A compiler may either not implement a behaviour (in that case, no configuration is available
  for that compiler, and the behaviour is completely ignored) or it must implement it exactly as declared in behaviours.xml
- implement properties:
- definitions: Commandline flags which the build system needs apart from options, for example to add a path to a tool or to define
  a constant for the tool used in this stage
- <error> and <warning> provide a regex to parse output for one specific error condition or warning
- There may be several of each, referring to different conditions
- Each regex only operates inside the stage defined by the context attribute (different from the current implementation!)
