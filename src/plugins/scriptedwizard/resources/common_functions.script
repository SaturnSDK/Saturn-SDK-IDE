//
// Common functions for all registered wizards
//

// Warnings On
function WarningsOn(base, compilerID)
{
    if (GetCompilerFactory().CompilerInheritsFrom(compilerID, _T("msvc*")))
    {
        base.AddCompilerOption(_T("/W3"));
    }
    else
    {
        // GCC options are used as fallback
        base.AddCompilerOption(_T("-Wall"));
    }
}

// Debug symbols On
function DebugSymbolsOn(base, compilerID)
{
    if (GetCompilerFactory().CompilerInheritsFrom(compilerID, _T("msvc*")))
    {
        base.AddCompilerOption(_T("/Zi"));
        base.AddCompilerOption(_T("/D_DEBUG"));
        base.AddLinkerOption(_T("/DEBUG"));
    }
    else
    {
        // GCC options are used as fallback
        base.AddCompilerOption(_T("-g"));
    }
}

// Optimizations On
function OptimizationsOn(base, compilerID)
{
    if (GetCompilerFactory().CompilerInheritsFrom(compilerID, _T("msvc*")))
    {
        base.AddCompilerOption(_T("/Og"));
        base.AddCompilerOption(_T("/Ox"));
        base.AddCompilerOption(_T("/DNDEBUG"));
    }
    else
    {
        // GCC options are used as fallback
        base.AddCompilerOption(_T("-O2"));
        base.AddLinkerOption(_T("-s"));
    }
}

// C++ Exceptions On
function CppExceptionsOn(base, compilerID)
{
    if (GetCompilerFactory().CompilerInheritsFrom(compilerID, _T("msvc*")))
    {
        base.AddCompilerOption(_T("/EHsc"));
    }
    else
    {
        // GCC options are used as fallback
        base.AddCompilerOption(_T("-fexceptions"));
    }
}

function VerifyDirectory(dir_or_macro)
{
    // try to make it a real path and verify it's existense
    local dir = ReplaceMacros(dir_or_macro, true);

    if (!IO.DirectoryExists(dir))
    {
        ShowError(_T("The directory you entered seems not to be valid.\n" +
                     "This wizard cannot continue."));
        return (_T(""));
    }

    return dir;
}

function VerifyMacro(macro)
{
    // try to make it a real path and verify it's existense
    local dir = ReplaceMacros(macro, true);

    // verify if there are macros used at all...
    if (macro.Matches(dir))
    {
        return (_T("")); // no macros used -> return empty
    }

    return dir;
}

// Get compiler include directory (taking GV's into account)
// selection        - the original directory selection the user has made
// defaultSelection - the default directory proposed by the wizard (using a macro)
// defaultSelection - the default include directory proposed by the wizard (using a macro)
// Returns: The include directory (which maybe translated from a macro)
function GetCompilerIncludeDir(selection, defaultSelection, defaultIncludeMacro)
{

    // make it a real path and verify it's existense
    local selection_nomacro = VerifyMacro(selection);

    // verify if there are macros used at all...
    if (selection_nomacro.IsEmpty())
    {
        // no macros used, direct path
        if (!IO.DirectoryExists(selection + wxFILE_SEP_PATH + _T("include")))
        {
            ShowError(_T("The path you entered seems valid, but the wizard " +
                         "can't locate the include directory.\n" +
                         "This wizard cannot continue."));
            return (_T(""));
        }
        return (selection + wxFILE_SEP_PATH + _T("include"));
    }

    // macros used

    if (selection.Matches(defaultSelection))
    {
        // default macro used

        // default include macro is usually: $(#GV.include)
        local defaultInclude_nomacro = ReplaceMacros(defaultIncludeMacro, true);
        if (!IO.DirectoryExists(defaultInclude_nomacro))
        {
            ShowError(_T("The macro you entered seems valid, but this wizard can't\n" +
                         "locate the include directory based on this macro.\n" +
                         "This wizard cannot continue."));
            return (_T(""));
        }

        // default include macro used
        return (defaultInclude_nomacro);
    }

    // non-default macro used

    if (!IO.DirectoryExists(selection_nomacro + wxFILE_SEP_PATH + _T("include")))
    {
        ShowError(_T("The macro you entered seems valid, but this wizard can't\n" +
                     "compute the include directory based on this macro.\n" +
                     "This wizard cannot continue."));
        return (_T(""));
    }

    return (selection_nomacro + wxFILE_SEP_PATH + _T("include"));
}

// Get compiler include macro (if possible and a GV has been provided)
// selection        - the original directory selection the user has made
// defaultSelection - the default directory proposed by the wizard (using a macro)
// defaultSelection - the default include directory proposed by the wizard (using a macro)
// Returns: The include macro (if possible), empty if not able to use a macro.
function GetCompilerIncludeMacro(selection, defaultSelection, defaultIncludeMacro)
{

    // make it a real path and verify it's existense
    local selection_nomacro = VerifyMacro(selection);

    // verify if there are macros used at all...
    if (!selection_nomacro.IsEmpty())
    {
        if (selection.Matches(defaultSelection))
        {
            // default macro used

            // default include macro is usually: $(#GV.include)
            local defaultInclude_nomacro = ReplaceMacros(defaultIncludeMacro, true);
            if (IO.DirectoryExists(defaultInclude_nomacro))
            {
                // default include macro used
                return (defaultInclude_nomacro);
            }
        }

        // non-default macro used

        if (IO.DirectoryExists(selection_nomacro + wxFILE_SEP_PATH + _T("include")))
        {
            return (selection_nomacro + wxFILE_SEP_PATH + _T("include"));
        }
    }

    // in all other cases no macro or is used or
    // the include macro cannot be computed
    return (_T(""));
}

// Get compiler library directory (taking GV's into account)
// selection        - the original directory selection the user has made
// defaultSelection - the default directory proposed by the wizard (using a macro)
// defaultSelection - the default library directory proposed by the wizard (using a macro)
// Returns: The library directory (which maybe translated from a macro)
function GetCompilerLibDir(selection, defaultSelection, defaultLibMacro)
{

    // make it a real path and verify it's existense
    local selection_nomacro = VerifyMacro(selection);

    // verify if there are macros used at all...
    if (selection_nomacro.IsEmpty())
    {
        // no macros used, direct path
        if (!IO.DirectoryExists(selection + wxFILE_SEP_PATH + _T("lib")))
        {
            ShowError(_T("The path you entered seems valid, but the wizard " +
                         "can't locate the library directory.\n" +
                         "This wizard cannot continue."));
            return (_T(""));
        }
        return (selection + wxFILE_SEP_PATH + _T("lib"));
    }

    // macros used

    if (selection.Matches(defaultSelection))
    {
        // default macro used

        // default lib macro is usually: $(#GV.lib)
        local defaultInclude_nomacro = ReplaceMacros(defaultLibMacro, true);
        if (!IO.DirectoryExists(defaultInclude_nomacro))
        {
            ShowError(_T("The macro you entered seems valid, but this wizard can't\n" +
                         "locate the library directory based on this macro.\n" +
                         "This wizard cannot continue."));
            return (_T(""));
        }

        // default lib macro used
        return (defaultInclude_nomacro);
    }

    // non-default macro used

    if (!IO.DirectoryExists(selection_nomacro + wxFILE_SEP_PATH + _T("lib")))
    {
        ShowError(_T("The macro you entered seems valid, but this wizard can't\n" +
                     "compute the library directory based on this macro.\n" +
                     "This wizard cannot continue."));
        return (_T(""));
    }

    return (selection_nomacro + wxFILE_SEP_PATH + _T("lib"));
}

// Get compiler library macro (if possible and a GV has been provided)
// selection        - the original directory selection the user has made
// defaultSelection - the default directory proposed by the wizard (using a macro)
// defaultSelection - the default library directory proposed by the wizard (using a macro)
// Returns: The library macro (if possible), empty if not able to use a macro.
function GetCompilerLibMacro(selection, defaultSelection, defaultLibMacro)
{

    // make it a real path and verify it's existense
    local selection_nomacro = VerifyMacro(selection);

    // verify if there are macros used at all...
    if (!selection_nomacro.IsEmpty())
    {
        if (selection.Matches(defaultSelection))
        {
            // default macro used

            // default library macro is usually: $(#GV.lib)
            local defaultLib_nomacro = ReplaceMacros(defaultLibMacro, true);
            if (IO.DirectoryExists(defaultLib_nomacro))
            {
                // default library macro used
                return (defaultLib_nomacro);
            }
        }

        // non-default macro used

        if (IO.DirectoryExists(selection_nomacro + wxFILE_SEP_PATH + _T("lib")))
        {
            return (selection_nomacro + wxFILE_SEP_PATH + _T("lib"));
        }
    }

    // in all other cases no macro or is used or
    // the library macro cannot be computed
    return (_T(""));
}

// verify the existence of a file of specific type
// dir  = the directory the file is expected in
// file = name of the file to look for
// type = descriptive name of the file to show in the error message
// Returns: true, if the file exists, false otherwise
function VerifyFile(dir, file, type)
{
    if (!IO.FileExists(dir + wxFILE_SEP_PATH + file))
    {
        ShowError(_T("The path you entered seems valid, but this wizard\n" +
                     "can't locate the following ") + type + _T(" file:\n") +
                     file + _T(" in it."));
        return false;
    }
    return true;
}

// verify the existence of a file of library type (add prefix lib, postfix .a and .lib)
// dir  = the directory the library is expected in
// file = name of the libryry to look for (usually for e.g. "libGL.a" providing "GL" is enough.
// type = descriptive name of the library to show in the error message
// Returns: true, if the library exists, false otherwise
function VerifyLibFile(dir, file, type)
{
    if (   (!IO.FileExists(dir + wxFILE_SEP_PATH + file))
        && (!IO.FileExists(dir + wxFILE_SEP_PATH + file + _T(".a")))
        && (!IO.FileExists(dir + wxFILE_SEP_PATH + file + _T(".lib")))
        && (!IO.FileExists(dir + wxFILE_SEP_PATH + _T("lib") + file))
        && (!IO.FileExists(dir + wxFILE_SEP_PATH + _T("lib") + file + _T(".a")))
        && (!IO.FileExists(dir + wxFILE_SEP_PATH + _T("lib") + file + _T(".lib"))) )

    {
        ShowError(_T("The path you entered seems valid, but this wizard\n" +
                     "can't locate the following ") + type + _T(" library file:\n") +
                     file + _T(" in it.\n" +
                     "(Also tried prepending lib and appending .a and .lib)."));
        return false;
    }
    return true;
}

// Add a file to a selection of target(s).
// Thus the wizard must have had a FilePathPanel for the selection of these.
// the_wiz  = a reference to the wizard (to access the targets indexes)
// the_file = name of the file (including fuill path) that shall be added
function AddFileToTargets(the_wiz, the_file)
{
    // get the first selected target to add the file to
    local tgtidx = the_wiz.GetFileTargetIndex();
    if (tgtidx != -1)
    {
        // obtain the currently active project to add the file to
        local prj = GetProjectManager().GetActiveProject();
        if (!IsNull(prj))
        {
            // add the file to the first selected target
            local pf = prj.AddFile(tgtidx, the_file);
            GetProjectManager().RebuildTree(); // make sure our view is current

            // if the file was added succesfully, (...)
            if (!IsNull(pf))
            {
                // add to this file the rest of the selected targets...
                tgtidx = the_wiz.GetFileTargetIndex();
                while (tgtidx != -1)
                {
                    local tgt = prj.GetBuildTarget(tgtidx);
                    if (!IsNull(tgt))
                        pf.AddBuildTarget(tgt.GetTitle());

                    tgtidx = the_wiz.GetFileTargetIndex();
                }
            }
        }
    }
}
